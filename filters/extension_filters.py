from aiogram import types
from aiogram.dispatcher.filters import BoundFilter
from database.accountant import RegisterUser, UserSubscription
import keyboards.inline as nav
from logger.log import logger
from states.state_user import FSMUser
from peewee import DoesNotExist, OperationalError


class UserRegister(BoundFilter):
    """
    –î–æ—á–µ—Ä–Ω–∏–π –∫–ª–∞—Å—Å UserID —Ä–æ–¥–∏—Ç–µ–ª—å BoundFilter —Å–æ–∑–¥–∞–Ω –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

    """

    async def check(self, message: types.Message):
        """
        –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        :param message:
        :return:
        """
        try:
            user = RegisterUser.get(RegisterUser.user_id == message.from_user.id)
            logger.info(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {message.from_user.first_name} –∑–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞')
            if user.user_id:
                return True
        except Exception as exc:
            logger.info(f'{exc.__class__.__name__}, {exc}')
            logger.info(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {message.from_user.first_name} –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç')
            await FSMUser.register_user.set()
            await message.answer(f'–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ {message.from_user.first_name}'
                                 f'\n–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã.'
                                 '\n–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–π—Ç–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é', reply_markup=nav.marcup_yes_no)
            return False


class UserSubscriptionFilter(BoundFilter):
    """

    """
    async def check(self, call: types.CallbackQuery) -> bool:
        if call.data in 'auto_payment':
            logger.info(f'–ò–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {call.from_user.first_name} –Ω–∞ –¥–æ—Å—Ç—É–ø –∫–æ—à–µ–ª—å–∫–∞')
            user_id = RegisterUser.get(RegisterUser.user_id == call.from_user.id)
            try:
                user_private = UserSubscription.get(UserSubscription.user_id == user_id.id)
                if user_private.private:
                    return True
            except DoesNotExist as exc:
                logger.info(f'{exc.__class__.__name__} {exc}')
            except OperationalError as exc:
                logger.error(f"{exc.__class__.__name__} {exc}")
            await call.answer('–≠—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞ üõë –¥–ª—è –í–∞—Å'
                              f'\n{call.from_user.first_name} –í—ã –Ω–µ –æ–ø–ª–∞—Ç–∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫—É', show_alert=True)
            return False


class AutoPaymentFilter(BoundFilter):
    async def check(self, call: types.CallbackQuery) -> bool:
        return call.data == 'auto_payment'


class WalletFilter(BoundFilter):
    async def check(self, message: types.Message) -> bool:
        return message.text == 'üëõ –ö–æ—à–µ–ª–µ–∫'


class ReportFilter(BoundFilter):
    async def check(self, message: types.Message) -> bool:
        return message.text == 'üìñ –û—Ç—á–µ—Ç'


class Number(BoundFilter):
    async def check(self, message: types.Message) -> bool:
        if len(message.text.split()) == 1:
            if message.text.isdigit():
                return True
            else:
                await message.answer('–í—ã –≤–µ–ª–∏ –Ω–µ –≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ. –í–≤–µ–¥–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ')
        elif len(message.text.split()) == 2:
            if message.text.split()[0].isdigit() and message.text.split()[1].isdigit():
                return True
            else:
                await message.answer('–í—ã –≤–µ–ª–∏ –Ω–µ –≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ. –í–≤–µ–¥–∏—Ç–µ –∑–∞–Ω–æ–≤–æ 2 —á–∏—Å–ª–∞ (–Ω–∞–ª. –±–µ–∑–Ω–∞–ª)')

        return False

